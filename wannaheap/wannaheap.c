/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
// void free(void *ptr);
// void __noreturn exit(int status);
// int puts(const char *s);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// void *memset(void *s, int c, size_t n);
// unsigned int alarm(unsigned int seconds);
// int close(int fd);
// char *_strdup(const char *s);
// ssize_t read(int fd, void *buf, size_t nbytes);
// void *calloc(size_t nmemb, size_t size);
// int strcmp(const char *s1, const char *s2);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int prctl(int option, ...);
// int IO_getc(_IO_FILE *fp);
// int munmap(void *addr, size_t len);
// __int64 _printf_chk(_QWORD, const char *, ...); weak
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// int open(const char *file, int oflag, ...);
// __int64 _isoc99_scanf(const char *, ...); weak
// void __noreturn exit(int status);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// __int64 __fastcall _fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall _cxa_finalize(void *);
void __fastcall __noreturn main(__int64 a1, char **a2, char **a3);
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void));
__int64 (**sub_D20())(void);
__int64 sub_D60(void); // weak
__int64 (**sub_DB0())(void);
__int64 sub_DF0(); // weak
void __noreturn handler();
unsigned __int64 sub_E40();
ssize_t __fastcall read_input(char *buf, size_t nbytes);
__int64 get_random();
int sub_16E0();
void *init_mmap();
unsigned __int64 create_data_heap();
char *__fastcall sub_18D0(unsigned __int64 a1);
__int64 menu();
void sub_1AC0();
__int64 __fastcall sub_1B20(__int64 a1, unsigned __int64 a2);
unsigned __int64 Allocate();
unsigned __int64 Read();
void sub_1DC0();
int get_char();
__int64 __fastcall sub_1E60(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_1F80(int *a1, const char *a2);
__int64 __fastcall sub_2070(unsigned __int16 *a1, __int64 a2);
void __fastcall init(unsigned int a1, __int64 a2, __int64 a3);
void fini(void); // idb
void term_proc();
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int _IO_getc(_IO_FILE *fp);
// int __fastcall __cxa_finalize(void *);
// __int64 ITM_deregisterTMCloneTable(void); weak
// __int64 _gmon_start__(void); weak
// __int64 Jv_RegisterClasses(void); weak

//-------------------------------------------------------------------------
// Data declarations

__int64 (__fastcall *off_202D28[2])() = { &sub_DF0, &sub_DB0 }; // weak
__int64 (__fastcall *off_202D30)() = &sub_DB0; // weak
_UNKNOWN unk_202D38; // weak
void *off_203008 = &off_203008; // idb
_UNKNOWN unk_203010; // weak
_UNKNOWN unk_203017; // weak
FILE *stdout; // idb
FILE *stdin; // idb
FILE *stderr; // idb
char byte_203048; // weak
__int64 qword_203050; // weak
__int64 qword_203058; // weak
char *data;
int dword_203068; // weak
void *addr; // idb


//----- (0000000000000B30) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 203150: using guessed type __int64 _gmon_start__(void);

//----- (0000000000000C20) ----------------------------------------------------
void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)
{
  char choice; // al

  sub_16E0(a1, a2, a3);
  init_mmap();
  create_data_heap();
  sub_1DC0();
  sub_E40();
  qword_203058 = qword_203050;
  while ( 1 )
  {
    while ( 1 )
    {
      menu();
      choice = get_char();
      if ( choice == 'E' )
      {
        puts("Don't give up\n");
        sub_1AC0();
        munmap(addr, 0x2000uLL);
        exit(0);
      }
      if ( choice > 'E' )
        break;
      if ( choice == 'A' )
        Allocate();
      else
invalid:
        puts("Invalid choice");
    }
    if ( choice == 'F' )
    {
      puts("Not implement !");
    }
    else
    {
      if ( choice != 'R' )
        goto invalid;
      Read();
    }
  }
}
// E40: using guessed type __int64 sub_E40(void);
// 16E0: using guessed type __int64 __fastcall sub_16E0(_QWORD, _QWORD, _QWORD);
// 1A30: using guessed type __int64 menu(void);
// 1D00: using guessed type __int64 Read(void);
// 1DC0: using guessed type __int64 sub_1DC0(void);
// 203050: using guessed type __int64 qword_203050;
// 203058: using guessed type __int64 qword_203058;

//----- (0000000000000CF0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (__fastcall *)(int, char **, char **))main, v4, &retaddr, (void (*)(void))init, fini, a3, &v5);
  __halt();
}
// CF6: positive sp value 8 has been found
// CFD: variable 'v3' is possibly undefined

//----- (0000000000000D20) ----------------------------------------------------
__int64 (**sub_D20())(void)
{
  __int64 (**result)(void); // rax

  result = (__int64 (**)(void))(&unk_203017 - &unk_203010);
  if ( (unsigned __int64)(&unk_203017 - &unk_203010) > 0xE )
  {
    result = &ITM_deregisterTMCloneTable;
    if ( &ITM_deregisterTMCloneTable )
      return (__int64 (**)(void))ITM_deregisterTMCloneTable();
  }
  return result;
}
// 203148: using guessed type __int64 ITM_deregisterTMCloneTable(void);

//----- (0000000000000D60) ----------------------------------------------------
__int64 sub_D60()
{
  return 0LL;
}
// D60: using guessed type __int64 sub_D60();

//----- (0000000000000DB0) ----------------------------------------------------
__int64 (**sub_DB0())(void)
{
  __int64 (**result)(void); // rax

  if ( !byte_203048 )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(off_203008);
    result = sub_D20();
    byte_203048 = 1;
  }
  return result;
}
// 203048: using guessed type char byte_203048;

//----- (0000000000000DF0) ----------------------------------------------------
__int64 sub_DF0()
{
  if ( unk_202D38 && &Jv_RegisterClasses )
    Jv_RegisterClasses();
  return sub_D60();
}
// D60: using guessed type __int64 sub_D60(void);
// DF0: using guessed type __int64 sub_DF0();
// 203158: using guessed type __int64 Jv_RegisterClasses(void);

//----- (0000000000000E20) ----------------------------------------------------
void __noreturn handler()
{
  puts("Timeout");
  exit(0);
}

//----- (0000000000000E40) ----------------------------------------------------
unsigned __int64 sub_E40()
{
  __int16 v1; // [rsp+0h] [rbp-11B8h] BYREF
  __int16 *v2; // [rsp+8h] [rbp-11B0h]
  __int16 v3; // [rsp+10h] [rbp-11A8h] BYREF
  char v4; // [rsp+12h] [rbp-11A6h]
  char v5; // [rsp+13h] [rbp-11A5h]
  int v6; // [rsp+14h] [rbp-11A4h]
  __int16 v7; // [rsp+18h] [rbp-11A0h]
  char v8; // [rsp+1Ah] [rbp-119Eh]
  char v9; // [rsp+1Bh] [rbp-119Dh]
  int v10; // [rsp+1Ch] [rbp-119Ch]
  __int16 v11; // [rsp+20h] [rbp-1198h]
  char v12; // [rsp+22h] [rbp-1196h]
  char v13; // [rsp+23h] [rbp-1195h]
  int v14; // [rsp+24h] [rbp-1194h]
  __int16 v15; // [rsp+28h] [rbp-1190h]
  char v16; // [rsp+2Ah] [rbp-118Eh]
  char v17; // [rsp+2Bh] [rbp-118Dh]
  int v18; // [rsp+2Ch] [rbp-118Ch]
  __int16 v19; // [rsp+30h] [rbp-1188h]
  char v20; // [rsp+32h] [rbp-1186h]
  char v21; // [rsp+33h] [rbp-1185h]
  int v22; // [rsp+34h] [rbp-1184h]
  __int16 v23; // [rsp+38h] [rbp-1180h]
  char v24; // [rsp+3Ah] [rbp-117Eh]
  char v25; // [rsp+3Bh] [rbp-117Dh]
  int v26; // [rsp+3Ch] [rbp-117Ch]
  __int16 v27; // [rsp+40h] [rbp-1178h]
  char v28; // [rsp+42h] [rbp-1176h]
  char v29; // [rsp+43h] [rbp-1175h]
  int v30; // [rsp+44h] [rbp-1174h]
  __int16 v31; // [rsp+48h] [rbp-1170h]
  char v32; // [rsp+4Ah] [rbp-116Eh]
  char v33; // [rsp+4Bh] [rbp-116Dh]
  int v34; // [rsp+4Ch] [rbp-116Ch]
  __int16 v35; // [rsp+50h] [rbp-1168h]
  char v36; // [rsp+52h] [rbp-1166h]
  char v37; // [rsp+53h] [rbp-1165h]
  int v38; // [rsp+54h] [rbp-1164h]
  __int16 v39; // [rsp+58h] [rbp-1160h]
  char v40; // [rsp+5Ah] [rbp-115Eh]
  char v41; // [rsp+5Bh] [rbp-115Dh]
  int v42; // [rsp+5Ch] [rbp-115Ch]
  __int16 v43; // [rsp+60h] [rbp-1158h]
  char v44; // [rsp+62h] [rbp-1156h]
  char v45; // [rsp+63h] [rbp-1155h]
  int v46; // [rsp+64h] [rbp-1154h]
  __int16 v47; // [rsp+68h] [rbp-1150h]
  char v48; // [rsp+6Ah] [rbp-114Eh]
  char v49; // [rsp+6Bh] [rbp-114Dh]
  int v50; // [rsp+6Ch] [rbp-114Ch]
  __int16 v51; // [rsp+70h] [rbp-1148h]
  char v52; // [rsp+72h] [rbp-1146h]
  char v53; // [rsp+73h] [rbp-1145h]
  int v54; // [rsp+74h] [rbp-1144h]
  __int16 v55; // [rsp+78h] [rbp-1140h]
  char v56; // [rsp+7Ah] [rbp-113Eh]
  char v57; // [rsp+7Bh] [rbp-113Dh]
  int v58; // [rsp+7Ch] [rbp-113Ch]
  __int16 v59; // [rsp+80h] [rbp-1138h]
  char v60; // [rsp+82h] [rbp-1136h]
  char v61; // [rsp+83h] [rbp-1135h]
  int v62; // [rsp+84h] [rbp-1134h]
  __int16 v63; // [rsp+88h] [rbp-1130h]
  char v64; // [rsp+8Ah] [rbp-112Eh]
  char v65; // [rsp+8Bh] [rbp-112Dh]
  int v66; // [rsp+8Ch] [rbp-112Ch]
  __int16 v67; // [rsp+90h] [rbp-1128h]
  char v68; // [rsp+92h] [rbp-1126h]
  char v69; // [rsp+93h] [rbp-1125h]
  int v70; // [rsp+94h] [rbp-1124h]
  __int16 v71; // [rsp+98h] [rbp-1120h]
  char v72; // [rsp+9Ah] [rbp-111Eh]
  char v73; // [rsp+9Bh] [rbp-111Dh]
  int v74; // [rsp+9Ch] [rbp-111Ch]
  __int16 v75; // [rsp+A0h] [rbp-1118h]
  char v76; // [rsp+A2h] [rbp-1116h]
  char v77; // [rsp+A3h] [rbp-1115h]
  int v78; // [rsp+A4h] [rbp-1114h]
  __int16 v79; // [rsp+A8h] [rbp-1110h]
  char v80; // [rsp+AAh] [rbp-110Eh]
  char v81; // [rsp+ABh] [rbp-110Dh]
  int v82; // [rsp+ACh] [rbp-110Ch]
  __int16 v83; // [rsp+B0h] [rbp-1108h]
  char v84; // [rsp+B2h] [rbp-1106h]
  char v85; // [rsp+B3h] [rbp-1105h]
  int v86; // [rsp+B4h] [rbp-1104h]
  __int16 v87; // [rsp+B8h] [rbp-1100h]
  char v88; // [rsp+BAh] [rbp-10FEh]
  char v89; // [rsp+BBh] [rbp-10FDh]
  int v90; // [rsp+BCh] [rbp-10FCh]
  __int16 v91; // [rsp+C0h] [rbp-10F8h]
  char v92; // [rsp+C2h] [rbp-10F6h]
  char v93; // [rsp+C3h] [rbp-10F5h]
  int v94; // [rsp+C4h] [rbp-10F4h]
  __int16 v95; // [rsp+C8h] [rbp-10F0h]
  char v96; // [rsp+CAh] [rbp-10EEh]
  char v97; // [rsp+CBh] [rbp-10EDh]
  int v98; // [rsp+CCh] [rbp-10ECh]
  __int16 v99; // [rsp+D0h] [rbp-10E8h]
  char v100; // [rsp+D2h] [rbp-10E6h]
  char v101; // [rsp+D3h] [rbp-10E5h]
  int v102; // [rsp+D4h] [rbp-10E4h]
  __int16 v103; // [rsp+D8h] [rbp-10E0h]
  char v104; // [rsp+DAh] [rbp-10DEh]
  char v105; // [rsp+DBh] [rbp-10DDh]
  int v106; // [rsp+DCh] [rbp-10DCh]
  __int16 v107; // [rsp+E0h] [rbp-10D8h]
  char v108; // [rsp+E2h] [rbp-10D6h]
  char v109; // [rsp+E3h] [rbp-10D5h]
  int v110; // [rsp+E4h] [rbp-10D4h]
  __int16 v111; // [rsp+E8h] [rbp-10D0h]
  char v112; // [rsp+EAh] [rbp-10CEh]
  char v113; // [rsp+EBh] [rbp-10CDh]
  int v114; // [rsp+ECh] [rbp-10CCh]
  __int16 v115; // [rsp+F0h] [rbp-10C8h]
  char v116; // [rsp+F2h] [rbp-10C6h]
  char v117; // [rsp+F3h] [rbp-10C5h]
  int v118; // [rsp+F4h] [rbp-10C4h]
  __int16 v119; // [rsp+F8h] [rbp-10C0h]
  char v120; // [rsp+FAh] [rbp-10BEh]
  char v121; // [rsp+FBh] [rbp-10BDh]
  int v122; // [rsp+FCh] [rbp-10BCh]
  __int16 v123; // [rsp+100h] [rbp-10B8h]
  char v124; // [rsp+102h] [rbp-10B6h]
  char v125; // [rsp+103h] [rbp-10B5h]
  int v126; // [rsp+104h] [rbp-10B4h]
  __int16 v127; // [rsp+108h] [rbp-10B0h]
  char v128; // [rsp+10Ah] [rbp-10AEh]
  char v129; // [rsp+10Bh] [rbp-10ADh]
  int v130; // [rsp+10Ch] [rbp-10ACh]
  __int16 v131; // [rsp+110h] [rbp-10A8h]
  char v132; // [rsp+112h] [rbp-10A6h]
  char v133; // [rsp+113h] [rbp-10A5h]
  int v134; // [rsp+114h] [rbp-10A4h]
  __int16 v135; // [rsp+118h] [rbp-10A0h]
  char v136; // [rsp+11Ah] [rbp-109Eh]
  char v137; // [rsp+11Bh] [rbp-109Dh]
  int v138; // [rsp+11Ch] [rbp-109Ch]
  __int16 v139; // [rsp+120h] [rbp-1098h]
  char v140; // [rsp+122h] [rbp-1096h]
  char v141; // [rsp+123h] [rbp-1095h]
  int v142; // [rsp+124h] [rbp-1094h]
  __int16 v143; // [rsp+128h] [rbp-1090h]
  char v144; // [rsp+12Ah] [rbp-108Eh]
  char v145; // [rsp+12Bh] [rbp-108Dh]
  int v146; // [rsp+12Ch] [rbp-108Ch]
  __int16 v147; // [rsp+130h] [rbp-1088h]
  char v148; // [rsp+132h] [rbp-1086h]
  char v149; // [rsp+133h] [rbp-1085h]
  int v150; // [rsp+134h] [rbp-1084h]
  __int16 v151; // [rsp+138h] [rbp-1080h]
  char v152; // [rsp+13Ah] [rbp-107Eh]
  char v153; // [rsp+13Bh] [rbp-107Dh]
  int v154; // [rsp+13Ch] [rbp-107Ch]
  __int16 v155; // [rsp+140h] [rbp-1078h]
  char v156; // [rsp+142h] [rbp-1076h]
  char v157; // [rsp+143h] [rbp-1075h]
  int v158; // [rsp+144h] [rbp-1074h]
  __int16 v159; // [rsp+148h] [rbp-1070h]
  char v160; // [rsp+14Ah] [rbp-106Eh]
  char v161; // [rsp+14Bh] [rbp-106Dh]
  int v162; // [rsp+14Ch] [rbp-106Ch]
  __int16 v163; // [rsp+150h] [rbp-1068h]
  char v164; // [rsp+152h] [rbp-1066h]
  char v165; // [rsp+153h] [rbp-1065h]
  int v166; // [rsp+154h] [rbp-1064h]
  __int16 v167; // [rsp+158h] [rbp-1060h]
  char v168; // [rsp+15Ah] [rbp-105Eh]
  char v169; // [rsp+15Bh] [rbp-105Dh]
  int v170; // [rsp+15Ch] [rbp-105Ch]
  __int16 v171; // [rsp+160h] [rbp-1058h]
  char v172; // [rsp+162h] [rbp-1056h]
  char v173; // [rsp+163h] [rbp-1055h]
  int v174; // [rsp+164h] [rbp-1054h]
  __int16 v175; // [rsp+168h] [rbp-1050h]
  char v176; // [rsp+16Ah] [rbp-104Eh]
  char v177; // [rsp+16Bh] [rbp-104Dh]
  int v178; // [rsp+16Ch] [rbp-104Ch]
  __int16 v179; // [rsp+170h] [rbp-1048h]
  char v180; // [rsp+172h] [rbp-1046h]
  char v181; // [rsp+173h] [rbp-1045h]
  int v182; // [rsp+174h] [rbp-1044h]
  __int16 v183; // [rsp+178h] [rbp-1040h]
  char v184; // [rsp+17Ah] [rbp-103Eh]
  char v185; // [rsp+17Bh] [rbp-103Dh]
  int v186; // [rsp+17Ch] [rbp-103Ch]
  __int16 v187; // [rsp+180h] [rbp-1038h]
  char v188; // [rsp+182h] [rbp-1036h]
  char v189; // [rsp+183h] [rbp-1035h]
  int v190; // [rsp+184h] [rbp-1034h]
  __int16 v191; // [rsp+188h] [rbp-1030h]
  char v192; // [rsp+18Ah] [rbp-102Eh]
  char v193; // [rsp+18Bh] [rbp-102Dh]
  int v194; // [rsp+18Ch] [rbp-102Ch]
  char v195[4104]; // [rsp+190h] [rbp-1028h] BYREF
  unsigned __int64 v196; // [rsp+1198h] [rbp-20h]

  v196 = __readfsqword(0x28u);
  v27 = 21;
  v7 = 21;
  v23 = 6;
  v15 = 32;
  memset(v195, 0, sizeof(v195));
  v11 = 6;
  v3 = 32;
  v19 = 21;
  v4 = 0;
  v5 = 0;
  v6 = 4;
  v8 = 1;
  v9 = 0;
  v10 = -1073741762;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v20 = 0;
  v21 = 1;
  v22 = 15;
  v24 = 0;
  v25 = 0;
  v26 = 2147418112;
  v28 = 0;
  v29 = 1;
  v30 = 231;
  v39 = 6;
  v47 = 6;
  v31 = 6;
  v35 = 21;
  v51 = 21;
  v43 = 21;
  v32 = 0;
  v33 = 0;
  v34 = 2147418112;
  v36 = 0;
  v37 = 1;
  v38 = 60;
  v40 = 0;
  v41 = 0;
  v42 = 2147418112;
  v44 = 0;
  v45 = 1;
  v46 = 2;
  v48 = 0;
  v49 = 0;
  v50 = 2147418112;
  v52 = 0;
  v53 = 1;
  v54 = 0;
  v55 = 5;
  v56 = -1;
  v57 = -1;
  v58 = sub_1F80(v195, "(check_read)");
  v59 = 21;
  v79 = 6;
  v63 = 6;
  v83 = 21;
  v71 = 6;
  v75 = 21;
  v87 = 5;
  v60 = 0;
  v61 = 1;
  v62 = 1;
  v64 = 0;
  v65 = 0;
  v66 = 2147418112;
  v67 = 21;
  v68 = 0;
  v69 = 1;
  v70 = 20;
  v72 = 0;
  v73 = 0;
  v74 = 2147418112;
  v76 = 0;
  v77 = 1;
  v78 = 3;
  v80 = 0;
  v81 = 0;
  v82 = 2147418112;
  v84 = 0;
  v85 = 1;
  v86 = 9;
  v88 = -1;
  v89 = -1;
  v99 = 6;
  v91 = 21;
  v95 = 6;
  v103 = 5;
  v90 = sub_1F80(v195, "(check_mmap)");
  v92 = 0;
  v93 = 1;
  v94 = 11;
  v96 = 0;
  v97 = 0;
  v98 = 2147418112;
  v100 = 0;
  v101 = 0;
  v102 = 0;
  v104 = -2;
  v105 = -2;
  v106 = sub_1F80(v195, "(check_read)");
  v107 = 32;
  v111 = 2;
  v115 = 32;
  v135 = 37;
  v119 = 2;
  v131 = 96;
  v123 = 37;
  v127 = 21;
  v108 = 0;
  v109 = 0;
  v110 = 32;
  v112 = 0;
  v113 = 0;
  v114 = 0;
  v116 = 0;
  v117 = 0;
  v118 = 36;
  v120 = 0;
  v121 = 0;
  v122 = 1;
  v124 = 4;
  v125 = 0;
  v126 = 0;
  v128 = 0;
  v129 = 5;
  v130 = 0;
  v132 = 0;
  v133 = 0;
  v134 = 0;
  v136 = 0;
  v137 = 2;
  v138 = 4919;
  v139 = 96;
  v143 = 6;
  v151 = 6;
  v155 = 5;
  v147 = 96;
  v140 = 0;
  v141 = 0;
  v142 = 1;
  v144 = 0;
  v145 = 0;
  v146 = 0;
  v148 = 0;
  v149 = 0;
  v150 = 1;
  v152 = 0;
  v153 = 0;
  v154 = 2147418112;
  v156 = -2;
  v157 = -2;
  v158 = sub_1F80(v195, "(check_mmap)");
  v163 = 2;
  v167 = 32;
  v171 = 2;
  v175 = 96;
  v179 = 84;
  v159 = 32;
  v183 = 21;
  v187 = 6;
  v160 = 0;
  v161 = 0;
  v162 = 32;
  v164 = 0;
  v165 = 0;
  v166 = 0;
  v168 = 0;
  v169 = 0;
  v170 = 36;
  v172 = 0;
  v173 = 0;
  v174 = 1;
  v176 = 0;
  v177 = 0;
  v178 = 0;
  v180 = 0;
  v181 = 0;
  v182 = 4;
  v184 = 0;
  v185 = 1;
  v186 = 0;
  v188 = 0;
  v189 = 0;
  v190 = 2147418112;
  v191 = 6;
  v192 = 0;
  v193 = 0;
  v194 = 0;
  sub_1E60(v195, &v3, 48LL);
  v1 = 48;
  v2 = &v3;
  prctl(38, 1LL, 0LL, 0LL, 0LL);
  prctl(22, 2LL, &v1);
  return __readfsqword(0x28u) ^ v196;
}
// 1E60: using guessed type __int64 __fastcall sub_1E60(_QWORD, _QWORD, _QWORD);
// 1F80: using guessed type __int64 __fastcall sub_1F80(_QWORD, _QWORD);

//----- (0000000000001610) ----------------------------------------------------
ssize_t __fastcall sub_1610(char *buf, size_t nbytes)
{
  ssize_t result; // rax
  char *v3; // rdx

  result = read(0, buf, (unsigned int)nbytes);
  if ( (int)result <= 0 )
  {
    puts("read error");
    exit(-1);
  }
  v3 = &buf[(int)result - 1];
  if ( *v3 == 10 )
    *v3 = 0;
  return result;
}

//----- (0000000000001660) ----------------------------------------------------
__int64 sub_1660()
{
  int v0; // eax
  int v1; // ebx
  unsigned int buf; // [rsp+4h] [rbp-14h] BYREF
  unsigned __int64 v4; // [rsp+8h] [rbp-10h]

  v4 = __readfsqword(0x28u);
  buf = 0;
  v0 = open("/dev/urandom", 0);
  if ( v0 < 0 )
  {
    puts("Error !");
    exit(3);
  }
  v1 = v0;
  read(v0, &buf, 4uLL);
  close(v1);
  return buf;
}

//----- (00000000000016E0) ----------------------------------------------------
int sub_16E0()
{
  signal(14, (__sighandler_t)handler);
  alarm(0x3Cu);
  setvbuf(stdout, 0LL, 2, 0LL);
  return setvbuf(stdin, 0LL, 2, 0LL);
}

//----- (0000000000001730) ----------------------------------------------------
void *sub_1730()
{
  int v0; // eax
  void *result; // rax

  v0 = get_random();
  result = mmap((void *)(v0 & 0xFFFFF000), 0x2000uLL, 3, 34, -1, 0LL);
  addr = result;
  if ( result == (void *)-1LL )
  {
    puts("Error !");
    exit(1337);
  }
  return result;
}
// 1660: using guessed type __int64 sub_1660(void);

//----- (0000000000001790) ----------------------------------------------------
unsigned __int64 create_data_heap()
{
  size_t size; // [rsp+0h] [rbp-28h] MAPDST BYREF
  unsigned __int64 v4; // [rsp+8h] [rbp-20h]

  v4 = __readfsqword(0x28u);
  size = 0LL;
  puts(" - Create data heap - ");
  _printf_chk(1LL, "Size :");
  _isoc99_scanf("%lu", &size);
  while ( size > 3224432 )
  {
    puts("Too big or too small !");
    _printf_chk(1LL, "Size :");
    _isoc99_scanf("%lu", &size);
  }
  data = (char *)calloc(1uLL, size + 1);
  if ( !data )
  {
    puts("Error !");
    exit(2);
  }
  _printf_chk(1LL, "Content :");
  read_input(data, (unsigned int)size);
  data[size] = 0;
  IO_getc(stdin);
  return __readfsqword(0x28u) ^ v4;
}
// BE0: using guessed type __int64 __fastcall _printf_chk(_QWORD, _QWORD);
// BF8: using guessed type __int64 _isoc99_scanf(const char *, ...);

//----- (00000000000018D0) ----------------------------------------------------
char *__fastcall sub_18D0(unsigned __int64 a1)
{
  unsigned int v1; // esi
  unsigned int v2; // ecx
  size_t v3; // rbp
  unsigned __int64 v4; // r14
  _DWORD *v5; // r13
  char *result; // rax
  int v7; // ecx
  _QWORD *v8; // rdx

  v1 = (unsigned int)get_random() % 0x217;
  v2 = (unsigned int)get_random() % 0x2170;
  if ( a1 > 0x313370 )
  {
    puts("Too big !");
    exit(4);
  }
  v3 = v2;
  v4 = v1 + a1;
  v5 = calloc(1uLL, v4 + v2);
  if ( !v5 )
  {
    puts("Error !");
    exit(5);
  }
  if ( v1 >= 8 )
  {
    *(_QWORD *)((char *)v5 + v1 - 8) = 0xDADADADADADADADALL;
    memset(v5, 0xDAu, 8LL * ((v1 - 1) >> 3));
  }
  else if ( (v1 & 4) != 0 )
  {
    *v5 = -623191334;
    *(_DWORD *)((char *)v5 + v1 - 4) = -623191334;
  }
  else if ( v1 )
  {
    *(_BYTE *)v5 = -38;
    if ( (v1 & 2) != 0 )
      *(_WORD *)((char *)v5 + v1 - 2) = -9510;
  }
  memset((char *)v5 + v4, 66, v3);
  result = (char *)v5 + v1;
  v7 = dword_203068;
  v8 = (char *)addr + 16 * (unsigned int)dword_203068;
  *v8 = result;
  v8[1] = v5;
  dword_203068 = v7 + 1;
  if ( (unsigned int)(v7 + 1) > 0x80 )
  {
    puts("OOM");
    exit(44);
  }
  return result;
}
// 203068: using guessed type int dword_203068;

//----- (0000000000001A30) ----------------------------------------------------
__int64 menu()
{
  puts("************************");
  puts("       Wanna Heap       ");
  puts("************************");
  puts("   [A]llocate           ");
  puts("   [R]ead               ");
  puts("   [F]ree               ");
  puts("   [E]xit               ");
  puts("************************");
  return _printf_chk(1LL, "> ");
}
// BE0: using guessed type __int64 __fastcall _printf_chk(_QWORD, _QWORD);

//----- (0000000000001AC0) ----------------------------------------------------
void sub_1AC0()
{
  unsigned int v0; // ebx
  __int64 v1; // rax

  if ( dword_203068 )
  {
    v0 = 0;
    do
    {
      v1 = v0++;
      free(*((void **)addr + 2 * v1 + 1));
    }
    while ( dword_203068 > v0 );
  }
}
// 203068: using guessed type int dword_203068;

//----- (0000000000001B20) ----------------------------------------------------
__int64 __fastcall sub_1B20(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rbp
  char *v4; // rax
  __int64 v5; // rdx
  char v6[24]; // [rsp+0h] [rbp-38h] BYREF
  unsigned __int64 v7; // [rsp+18h] [rbp-20h]

  v7 = __readfsqword(0x28u);
  if ( qword_203050 != a1 )
  {
    if ( a2 <= *(_QWORD *)(a1 + 16) )
    {
      v2 = sub_1B20(*(_QWORD *)a1, a2);
      *(_QWORD *)a1 = v2;
      if ( *(_DWORD *)(v2 + 32) > *(_DWORD *)(a1 + 32) )
      {
        *(_QWORD *)a1 = *(_QWORD *)(v2 + 8);
        *(_QWORD *)(v2 + 8) = a1;
        return v2;
      }
    }
    else
    {
      v2 = sub_1B20(*(_QWORD *)(a1 + 8), a2);
      *(_QWORD *)(a1 + 8) = v2;
      if ( *(_DWORD *)(v2 + 32) > *(_DWORD *)(a1 + 32) )
      {
        *(_QWORD *)(a1 + 8) = *(_QWORD *)v2;
        *(_QWORD *)v2 = a1;
        return v2;
      }
    }
    return a1;
  }
  v2 = sub_18D0(40LL);
  if ( !v2 )
  {
    puts("Error !");
    exit(23);
  }
  _printf_chk(1LL, "data :");
  read_input(v6, 0x18uLL);
  v4 = _strdup(v6);
  v5 = qword_203050;
  *(_QWORD *)(v2 + 24) = v4;
  *(_QWORD *)(v2 + 16) = a2;
  *(_QWORD *)(v2 + 8) = v5;
  *(_QWORD *)v2 = v5;
  *(_DWORD *)(v2 + 32) = get_random();
  return v2;
}
// BE0: using guessed type __int64 __fastcall _printf_chk(_QWORD, _QWORD);
// 18D0: using guessed type __int64 __fastcall sub_18D0(_QWORD);
// 203050: using guessed type __int64 qword_203050;

//----- (0000000000001C90) ----------------------------------------------------
unsigned __int64 Allocate()
{
  __int64 key; // [rsp+0h] [rbp-18h] BYREF
  unsigned __int64 v2; // [rsp+8h] [rbp-10h]

  v2 = __readfsqword(0x28u);
  key = 0LL;
  _printf_chk(1LL, "key :");
  _isoc99_scanf("%lu", &key);
  qword_203058 = sub_1B20(qword_203058, key);
  return __readfsqword(0x28u) ^ v2;
}
// BE0: using guessed type __int64 __fastcall _printf_chk(_QWORD, _QWORD);
// BF8: using guessed type __int64 _isoc99_scanf(const char *, ...);
// 1B20: using guessed type __int64 __fastcall sub_1B20(_QWORD, _QWORD);
// 203058: using guessed type __int64 qword_203058;

//----- (0000000000001D00) ----------------------------------------------------
unsigned __int64 Read()
{
  __int64 i; // rax
  unsigned __int64 v2; // [rsp+0h] [rbp-18h] BYREF
  unsigned __int64 v3; // [rsp+8h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  v2 = 0LL;
  _printf_chk(1LL, "key:");
  _isoc99_scanf("%lu", &v2);
  for ( i = qword_203058; ; i = *(_QWORD *)(i + 8) )
  {
    if ( i == qword_203050 )
    {
LABEL_5:
      _printf_chk(1LL, "Can't Not found : %lu\n", v2);
      goto LABEL_6;
    }
    while ( v2 < *(_QWORD *)(i + 16) )
    {
      i = *(_QWORD *)i;
      if ( i == qword_203050 )
        goto LABEL_5;
    }
    if ( v2 <= *(_QWORD *)(i + 16) )
      break;
  }
  _printf_chk(1LL, "data : %s\n", *(const char **)(i + 24));
LABEL_6:
  close(1);
  return __readfsqword(0x28u) ^ v3;
}
// BE0: using guessed type __int64 _printf_chk(_QWORD, const char *, ...);
// BF8: using guessed type __int64 _isoc99_scanf(const char *, ...);
// 203050: using guessed type __int64 qword_203050;
// 203058: using guessed type __int64 qword_203058;

//----- (0000000000001DC0) ----------------------------------------------------
void sub_1DC0()
{
  __int64 v0; // rax

  if ( !qword_203050 )
  {
    v0 = sub_18D0(40LL);
    qword_203050 = v0;
    if ( !v0 )
    {
      puts("error");
      exit(3);
    }
    *(_QWORD *)(v0 + 8) = v0;
    *(_QWORD *)v0 = v0;
    *(_DWORD *)(v0 + 32) = 0;
  }
}
// 18D0: using guessed type __int64 __fastcall sub_18D0(_QWORD);
// 203050: using guessed type __int64 qword_203050;

//----- (0000000000001E20) ----------------------------------------------------
int get_char()
{
  int result; // eax

  result = IO_getc(stdin);
  if ( (_BYTE)result == 10 )
    return IO_getc(stdin);
  return result;
}

//----- (0000000000001E60) ----------------------------------------------------
__int64 __fastcall sub_1E60(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // ecx
  __int64 v4; // rax
  int v5; // edx
  int v6; // ecx
  __int16 v7; // si
  __int64 v8; // rsi
  int v9; // r8d
  __int64 v11; // rsi
  __int64 v12; // rcx
  const char *v13; // rdx

  v3 = a3 - 1;
  if ( (unsigned __int64)(a3 - 1) > 0xFFF )
    return 0xFFFFFFFFLL;
  v4 = a2 + 8 * a3 - 8;
  v5 = a3 - 1;
  v6 = ~v3;
  while ( *(_WORD *)v4 != 5 )
  {
    --v5;
    v4 -= 8LL;
    ++v6;
    if ( v5 == -1 )
      return 0LL;
  }
  while ( 1 )
  {
    v7 = __ROL2__(*(_WORD *)(v4 + 2), 8);
    if ( v7 != -258 )
      break;
    v11 = a1 + 16LL * *(unsigned int *)(v4 + 4);
    if ( *(_DWORD *)(v11 + 16) != -1 )
    {
      v12 = *(_QWORD *)(v11 + 8);
      v13 = "Duplicate label use: '%s'\n";
      goto LABEL_16;
    }
    *(_DWORD *)(v11 + 16) = v5;
    *(_DWORD *)(v4 + 4) = 0;
    *(_BYTE *)(v4 + 2) = 0;
    *(_BYTE *)(v4 + 3) = 0;
LABEL_9:
    --v5;
    v4 -= 8LL;
    ++v6;
    if ( v5 == -1 )
      return 0LL;
    while ( *(_WORD *)v4 != 5 )
    {
      --v5;
      v4 -= 8LL;
      ++v6;
      if ( v5 == -1 )
        return 0LL;
    }
  }
  if ( v7 != -1 )
    goto LABEL_9;
  v8 = a1 + 16LL * *(unsigned int *)(v4 + 4);
  v9 = *(_DWORD *)(v8 + 16);
  if ( v9 != -1 )
  {
    *(_BYTE *)(v4 + 2) = 0;
    *(_BYTE *)(v4 + 3) = 0;
    *(_DWORD *)(v4 + 4) = v6 + v9;
    goto LABEL_9;
  }
  v12 = *(_QWORD *)(v8 + 8);
  v13 = "Unresolved label: '%s'\n";
LABEL_16:
  _fprintf_chk(stderr, 1LL, v13, v12);
  return 1LL;
}
// C10: using guessed type __int64 __fastcall _fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000001F80) ----------------------------------------------------
__int64 __fastcall sub_1F80(int *a1, const char *a2)
{
  int v2; // r13d
  unsigned __int64 v3; // rbx
  unsigned __int64 v4; // r15
  unsigned int v5; // ebp
  __int64 result; // rax

  v2 = *a1;
  if ( *a1 == 256 )
  {
    fwrite("Too many labels\n", 1uLL, 0x10uLL, stderr);
    exit(1);
  }
  if ( v2 )
  {
    v3 = (unsigned __int64)(a1 + 2);
    v4 = (unsigned __int64)&a1[4 * v2 + 2];
    if ( (unsigned __int64)(a1 + 2) >= v4 )
    {
      result = 0LL;
    }
    else
    {
      v5 = 0;
      do
      {
        if ( !strcmp(a2, *(const char **)v3) )
          return v5;
        v3 += 16LL;
        ++v5;
      }
      while ( v4 > v3 );
      result = v5;
    }
    *(_QWORD *)v3 = a2;
    *(_DWORD *)(v3 + 8) = -1;
    *a1 = v2 + 1;
  }
  else
  {
    *((_QWORD *)a1 + 1) = a2;
    a1[4] = -1;
    result = 0LL;
    *a1 = 1;
  }
  return result;
}

//----- (0000000000002070) ----------------------------------------------------
__int64 __fastcall sub_2070(unsigned __int16 *a1, __int64 a2)
{
  unsigned __int64 v2; // rbp
  unsigned __int16 *v3; // rbx
  __int64 v4; // rcx
  __int64 v5; // rdx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 result; // rax

  v2 = (unsigned __int64)&a1[4 * a2];
  if ( (unsigned __int64)a1 < v2 )
  {
    v3 = a1;
    do
    {
      v4 = *((unsigned __int8 *)v3 + 2);
      v5 = *v3;
      v6 = *((unsigned __int8 *)v3 + 3);
      v7 = *((unsigned int *)v3 + 1);
      v3 += 4;
      result = _printf_chk(1LL, "{ code=%u,jt=%u,jf=%u,k=%u },\n", v5, v4, v6, v7);
    }
    while ( v2 > (unsigned __int64)v3 );
  }
  return result;
}
// BE0: using guessed type __int64 _printf_chk(_QWORD, const char *, ...);

//----- (00000000000020C0) ----------------------------------------------------
void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)
{
  signed __int64 v4; // rbp
  __int64 i; // rbx

  v4 = &off_202D30 - off_202D28;
  init_proc();
  if ( v4 )
  {
    for ( i = 0LL; i != v4; ++i )
      ((void (__fastcall *)(_QWORD, __int64, __int64))off_202D28[i])(a1, a2, a3);
  }
}
// 202D28: using guessed type __int64 (__fastcall *off_202D28[2])();
// 202D30: using guessed type __int64 (__fastcall *off_202D30)();

//----- (0000000000002134) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=79 queued=27 decompiled=27 lumina nreq=0 worse=0 better=0
// ALL OK, 27 function(s) have been successfully decompiled
