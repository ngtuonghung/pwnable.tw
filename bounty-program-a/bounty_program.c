/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// int printf(const char *format, ...);
// void *memset(void *s, int c, size_t n);
// int puts(const char *s);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// void *malloc(size_t size);
// void __noreturn _exit(int status);
// char *fgets(char *s, int n, FILE *stream);
// void free(void *ptr);
// __int64 __fastcall __read_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// char *strdup(const char *s);
// int strcmp(const char *s1, const char *s2);
// char *strtok(char *s, const char *delim);
// void *calloc(size_t nmemb, size_t size);
// int rand(void);
// void *memcpy(void *dest, const void *src, size_t n);
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void));
char *__fastcall gets_input(char *a1, int a2);
__int64 read_long();
void __fastcall read_input(char *buf, unsigned int len);
User *Register();
unsigned __int64 AddProduct();
VulnType *__fastcall AllocateType(const char *type_name, int price);
__int64 __fastcall FreeType(char *name);
void AddVulnType();
int ShowTypes();
void RemoveVulnType();
int ShowProduct();
int ShowVulnDetail();
Product *__fastcall AddReportToProduct(Product *product, BugReport *report);
Product *__fastcall RemoveBugFromProduct(Product *product, BugReport *bugs);
void SubmitReport();
int DeleteReport();
unsigned __int64 ModifyReport();
int EvalVuln();
unsigned __int64 UserInfo();
void RemoveUser();
void ChangePassword();
void ChangeContact();
__int64 Bounty();
void __fastcall __noreturn main(const char *, char **, char **);
void __fastcall init(unsigned int, __int64, __int64);
void fini(void); // idb
// void *malloc(size_t size);
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// void free(void *ptr);

//-------------------------------------------------------------------------
// Data declarations

const char byte_360F = '\xE2'; // idb
FILE *stderr; // idb
FILE *stream; // idb
char isLoggedIn; // weak
User *user;
User *admin;
User *user_head;
Product *Products[8];
VulnType *VulnTypes[8];


//----- (0000000000000B80) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 2051F8: using guessed type __int64 _gmon_start__(void);

//----- (0000000000000BA0) ----------------------------------------------------
void sub_BA0()
{
  JUMPOUT(0LL);
}
// BA6: control flows out of bounds to 0

//----- (0000000000000D50) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (__fastcall *)(int, char **, char **))main, v4, &retaddr, (void (*)(void))init, fini, a3, &v5);
  __halt();
}
// D56: positive sp value 8 has been found
// D5D: variable 'v3' is possibly undefined

//----- (0000000000000D80) ----------------------------------------------------
void *sub_D80()
{
  return &unk_205010;
}

//----- (0000000000000DC0) ----------------------------------------------------
__int64 sub_DC0()
{
  return 0LL;
}
// DC0: using guessed type __int64 sub_DC0();

//----- (0000000000000E10) ----------------------------------------------------
void *sub_E10()
{
  void *result; // rax

  if ( !byte_205050 )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(off_205008);
    result = sub_D80();
    byte_205050 = 1;
  }
  return result;
}
// 205050: using guessed type char byte_205050;

//----- (0000000000000E50) ----------------------------------------------------
__int64 sub_E50()
{
  return sub_DC0();
}
// DC0: using guessed type __int64 sub_DC0(void);
// E50: using guessed type __int64 sub_E50();

//----- (0000000000000E5A) ----------------------------------------------------
void __noreturn handler()
{
  puts("Timeout");
  _exit(1);
}

//----- (0000000000000E7B) ----------------------------------------------------
char *__fastcall gets_input(char *a1, int a2)
{
  return fgets(a1, a2, stream);                 // read n-1
}

//----- (0000000000000EA9) ----------------------------------------------------
__int64 sub_EA9()
{
  char nptr[40]; // [rsp+10h] [rbp-30h] BYREF
  unsigned __int64 v2; // [rsp+38h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  __read_chk(0LL, nptr, 32LL, 32LL);
  return atoll(nptr);
}
// C80: using guessed type __int64 __fastcall __read_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000000F0A) ----------------------------------------------------
void __fastcall read_input(char *buf, unsigned int len)
{
  int chk; // [rsp+1Ch] [rbp-4h]

  if ( len && buf )
  {
    if ( (len & 0x80000000) != 0 )
      _exit(-2);
    chk = __read_chk(0LL, buf, len - 1, len);
    if ( chk <= 0 )
    {
      puts("read error");
      _exit(1);
    }
    if ( buf[chk - 1] == 10 )
      buf[chk - 1] = 0;
  }
}
// C80: using guessed type __int64 __fastcall __read_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000000FAB) ----------------------------------------------------
int Menu()
{
  puts("$$$$$$$$$$$$$$$$$$$$$$$$$");
  puts(&byte_32B5);
  puts("$$$$$$$$$$$$$$$$$$$$$$$$$");
  if ( isLoggedIn )
    puts(" 1. Bounty              ");
  else
    puts(" 1. Login               ");
  if ( isLoggedIn )
    puts(" 2. Change password     ");
  else
    puts(" 2. Register            ");
  puts(" 3. Show Product        ");
  if ( isLoggedIn )
  {
    puts(" 4. Change contact            ");
    puts(" 5. Remove user               ");
    puts(" 6. Userinfo                  ");
    puts(" 7. Logout                    ");
  }
  puts(" 0. Exit                ");
  puts("$$$$$$$$$$$$$$$$$$$$$$$$$");
  return printf("Your choice: ");
}
// 205068: using guessed type char isLoggedIn;

//----- (0000000000001090) ----------------------------------------------------
int sub_1090()
{
  puts("$$$$$$$$$$$$$$$$$$$$$$$$$");
  puts(&byte_33F6);
  puts("$$$$$$$$$$$$$$$$$$$$$$$$$");
  puts(" 1. Add new product     ");
  puts(" 2. Add new type        ");
  puts(" 3. Submit a bug report ");
  puts(" 4. Remove type         ");
  puts(" 5. Modify a bug report ");
  puts(" 6. Show vulnerability  ");
  puts(" 7. Evalute vulnerability");
  puts(" 8. Delete a bug report ");
  puts(" 0. Return              ");
  puts("$$$$$$$$$$$$$$$$$$$$$$$$$");
  return printf("Your choice: ");
}

//----- (0000000000001144) ----------------------------------------------------
User *Register()
{
  User *result; // rax
  User *new_user; // [rsp+8h] [rbp-8h]

  new_user = (User *)malloc(88uLL);
  if ( !new_user )
  {
    puts("Error!");
    _exit(1);
  }
  new_user->uid = rand();
  printf("Username:");
  read_input(new_user->username, 31u);
  printf("Password:");
  read_input(new_user->password, 16u);
  new_user->contact = (char *)calloc(1uLL, 32uLL);
  printf("Contact:");
  read_input(new_user->contact, 32u);
  LODWORD(new_user->balance) = 0;
  LODWORD(new_user->report_count) = 0;
  if ( user_head )
  {
    new_user->next = user_head;
    result = new_user;
    user_head = new_user;
  }
  else
  {
    user_head = new_user;
    admin = new_user;                           // first user to register is admin
    result = new_user;
    new_user->next = 0LL;
  }
  return result;
}

//----- (000000000000127A) ----------------------------------------------------
unsigned __int64 Login()
{
  User *current_user; // [rsp+8h] [rbp-48h]
  char password[16]; // [rsp+10h] [rbp-40h] BYREF
  char username[40]; // [rsp+20h] [rbp-30h] BYREF
  unsigned __int64 v4; // [rsp+48h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  memset(username, 0, 32uLL);                   // only clear 32 bytes
  memset(password, 0, sizeof(password));        // fully cleared
  printf("Username:");
  read_input(username, 32u);
  printf("Password:");
  read_input(password, 16u);
  if ( user_head )
  {
    for ( current_user = user_head; current_user; current_user = current_user->next )
    {
      if ( !strncmp(current_user->username, username, 31uLL) && !strncmp(current_user->password, password, 15uLL) )
      {
        isLoggedIn = 1;
        puts("Login success !");
        user = current_user;
        return __readfsqword(0x28u) ^ v4;
      }
    }
  }
  puts("Invalid user or password !");
  return __readfsqword(0x28u) ^ v4;
}
// 205068: using guessed type char isLoggedIn;

//----- (00000000000013B3) ----------------------------------------------------
unsigned __int64 AddProduct()
{
  int index; // [rsp+0h] [rbp-60h]
  int new_product_id; // [rsp+4h] [rbp-5Ch]
  Product *new_product; // [rsp+8h] [rbp-58h]
  char buf[72]; // [rsp+10h] [rbp-50h] BYREF
  unsigned __int64 v5; // [rsp+58h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  memset(buf, 0, 64uLL);                        // cleared
  printf("Name of Product:");
  read_input(buf, 48u);
  for ( index = 0; index <= 7; ++index )
  {
    if ( Products[index] && !strcmp(Products[index]->name, buf) )
    {
      puts("Already have this product !");
      return __readfsqword(0x28u) ^ v5;
    }
  }
  for ( new_product_id = 0; new_product_id <= 7; ++new_product_id )
  {
    if ( !Products[new_product_id] )
    {
      new_product = (Product *)calloc(1uLL, 0x58uLL);
      if ( !new_product )
      {
        puts("Error !");
        _exit(-3);
      }
      memcpy(new_product, buf, 48uLL);
      memset(buf, 0, 64uLL);                    // clear again
      printf("Company:");
      read_input(buf, 32u);
      new_product->company = strdup(buf);       // safe
      new_product->bugs = 0LL;
      printf("Comment:");
      read_input(new_product->comment, 16u);
      Products[new_product_id] = new_product;
      return __readfsqword(0x28u) ^ v5;
    }
  }
  return __readfsqword(0x28u) ^ v5;
}

//----- (00000000000015B1) ----------------------------------------------------
VulnType *__fastcall AllocateType(const char *type_name, int price)
{
  int index; // [rsp+10h] [rbp-10h]
  int type_id; // [rsp+14h] [rbp-Ch]
  VulnType *new_type; // [rsp+18h] [rbp-8h]

  if ( !type_name )
  {
    puts("Error !");
    _exit(-1);
  }
  for ( index = 0; index <= 7; ++index )
  {
    if ( VulnTypes[index] && !strcmp(VulnTypes[index]->name, type_name) )
      return 0LL;
  }
  for ( type_id = 0; type_id <= 7; ++type_id )
  {
    if ( !VulnTypes[type_id] )
    {
      new_type = (VulnType *)calloc(1uLL, 16uLL);
      new_type->name = strdup(type_name);
      new_type->price = price;
      new_type->ref_count = 1;
      VulnTypes[type_id] = new_type;
      return new_type;
    }
  }
  return 0LL;
}

//----- (00000000000016EB) ----------------------------------------------------
__int64 __fastcall FreeType(char *name)
{
  int type_id; // [rsp+1Ch] [rbp-4h]

  if ( !name )
  {
    puts("Error !");
    _exit(-1);
  }
  for ( type_id = 0; type_id <= 7; ++type_id )
  {
    if ( VulnTypes[type_id] && !strcmp(VulnTypes[type_id]->name, name) && VulnTypes[type_id]->ref_count == 1 )
    {
      free(VulnTypes[type_id]->name);
      free(VulnTypes[type_id]);
      VulnTypes[type_id] = 0LL;                 // no UAF
      return 1LL;
    }
  }
  return 0LL;
}

//----- (000000000000180E) ----------------------------------------------------
void AddVulnType()
{
  __int64 size; // rsi
  int price; // [rsp+4h] [rbp-1Ch]
  char *type_name; // [rsp+8h] [rbp-18h]
  char *types; // [rsp+18h] [rbp-8h]

  printf("Size:");
  size = read_long();
  types = (char *)calloc(1uLL, size);           // arbitrary size allocation
  puts("(Note:You can add many types at the same time)");
  puts("(Example: SQLI,Buffer overflow,LFI)");
  printf("Type:");
  read_input(types, size);
  for ( type_name = strtok(types, ","); type_name; type_name = strtok(0LL, ",") )
  {
    printf("type: %s\n", type_name);
    printf("Price:");
    price = read_long();
    if ( AllocateType(type_name, price) )
      puts("Success !");
    else
      puts(&byte_360F);
  }
  free(types);                                  // out of scope
}

//----- (0000000000001954) ----------------------------------------------------
int ShowTypes()
{
  VulnType *type; // rax
  int type_id; // [rsp+Ch] [rbp-4h]

  LODWORD(type) = puts("*********************************");
  for ( type_id = 0; type_id <= 7; ++type_id )
  {
    type = VulnTypes[type_id];
    if ( type )
    {
      printf("ID > %d\n", (unsigned int)type_id);
      printf("Type > %s\n", VulnTypes[type_id]->name);
      printf("Price > %u\n", (unsigned int)VulnTypes[type_id]->price);
      LODWORD(type) = puts("*********************************");
    }
  }
  return (int)type;
}

//----- (0000000000001A21) ----------------------------------------------------
void RemoveVulnType()
{
  __int64 size; // rsi
  char *type_name; // [rsp+8h] [rbp-8h]

  printf("Size:");
  size = read_long();
  type_name = (char *)calloc(1uLL, size);       // arbitrary size allocation
  printf("Type:");
  read_input(type_name, size);
  if ( (unsigned __int8)FreeType(type_name) != 1 )
    puts("No such type !");
  else
    puts("success !");
  free(type_name);
}

//----- (0000000000001ACE) ----------------------------------------------------
int ShowProduct()
{
  Product *product; // rax
  int product_id; // [rsp+Ch] [rbp-4h]

  LODWORD(product) = puts(">-------------------------------<");
  for ( product_id = 0; product_id <= 7; ++product_id )
  {
    product = Products[product_id];
    if ( product )
    {
      printf("ID > %d\n", (unsigned int)product_id);
      printf("Name > %s\n", Products[product_id]->name);
      printf("Company > %s\n", Products[product_id]->company);
      LODWORD(product) = puts(">-------------------------------<");
    }
  }
  return (int)product;
}

//----- (0000000000001B9A) ----------------------------------------------------
int ShowVulnDetail()
{
  BugReport *v0; // rax
  BugReport *bugs; // [rsp+0h] [rbp-10h]
  unsigned __int64 product_id; // [rsp+8h] [rbp-8h]

  printf("Product ID:");
  product_id = read_long();
  if ( product_id > 7 )
  {
    puts("Out of bound !");
    _exit(-5);
  }
  if ( Products[product_id] )
  {
    printf("ID > %lu\n", product_id);
    printf("Name > %s\n", Products[product_id]->name);
    printf("Company > %s\n", Products[product_id]->company);
    if ( Products[product_id]->bugs )
    {
      bugs = Products[product_id]->bugs;
      puts(&byte_36D0);
      do
      {
        // if user is admin, then display all vuln
        // if not, can cause infinite loop
        if ( user == admin || bugs->owner == user )
        {
          printf("Bug ID > %u\n", LODWORD(bugs->id));
          printf("Title > %s\n", bugs->title);
          printf("Type > %s\n", *(const char **)bugs->type);
          printf("Reporter > %s\n", bugs->owner->username);
          printf("Descripton > %s\n", bugs->description);
          bugs = bugs->next;
          puts(&byte_36D0);
        }
        v0 = Products[product_id]->bugs;
      }
      while ( bugs != v0 );
    }
    else
    {
      LODWORD(v0) = puts("No bug!");
    }
  }
  else
  {
    LODWORD(v0) = puts("No such product !");
  }
  return (int)v0;
}

//----- (0000000000001DF2) ----------------------------------------------------
Product *__fastcall AddReportToProduct(Product *product, BugReport *report)
{
  Product *result; // rax
  BugReport *prev; // [rsp+18h] [rbp-8h]

  if ( !product || !report )
  {
    puts("Error !");
    _exit(-1337);
  }
  if ( product->bugs )
  {
    prev = product->bugs->prev;
    prev->next = report;
    product->bugs->prev = report;
    report->next = product->bugs;
    result = (Product *)report;
    report->prev = prev;
  }
  else
  {
    report->next = report;
    report->prev = report;
    result = product;
    product->bugs = report;
  }
  return result;
}

//----- (0000000000001EC9) ----------------------------------------------------
Product *__fastcall RemoveBugFromProduct(Product *product, BugReport *bugs)
{
  Product *result; // rax
  BugReport *next; // [rsp+10h] [rbp-10h]
  BugReport *prev; // [rsp+18h] [rbp-8h]

  if ( !product || !bugs )
  {
    puts("Error !");
    _exit(-1338);
  }
  next = bugs->next;
  prev = bugs->prev;
  if ( bugs != next->prev || bugs != prev->next )
  {
    puts("Memory currpution !");
    _exit(56746);
  }
  if ( next == bugs && prev == bugs )
  {
    result = product;
    product->bugs = 0LL;
  }
  else if ( bugs == product->bugs )
  {
    next->prev = prev;
    prev->next = next;
    result = product;
    product->bugs = next;
  }
  else
  {
    next->prev = prev;
    result = (Product *)prev;
    prev->next = next;
  }
  return result;
}

//----- (0000000000001FE6) ----------------------------------------------------
void SubmitReport()
{
  unsigned __int64 size; // [rsp+10h] [rbp-20h]
  BugReport *new_report; // [rsp+18h] [rbp-18h]
  Product *product; // [rsp+20h] [rbp-10h]
  unsigned __int64 product_id; // [rsp+28h] [rbp-8h]
  unsigned __int64 type_id; // [rsp+28h] [rbp-8h]

  new_report = (BugReport *)calloc(1uLL, 320uLL);
  if ( !new_report )
  {
    puts("Error !");
    _exit(-4);
  }
  ShowProduct();
  printf("Product ID:");
  product_id = read_long();
  if ( product_id <= 7
    && Products[product_id]
    && (product = Products[product_id], ShowTypes(), printf("Type:"), type_id = read_long(), type_id <= 7)
    && VulnTypes[type_id] )
  {
    new_report->type = VulnTypes[type_id];
    ++new_report->type->ref_count;
    new_report->owner = user;
    ++LODWORD(user->report_count);
    printf("Title:");
    read_input(new_report->title, 255u);
    printf("ID:");
    LODWORD(new_report->id) = read_long();      // doesnt check for existing ID
    printf("Length of descripton:");
    size = read_long();
    if ( size <= 1031 )                         // min size is 1032
      size = 1032LL;
    new_report->description = (char *)malloc(size);// arbitrary large size allocation
    if ( !new_report->description )
    {
      puts("Error !");
      _exit(-5);
    }
    gets_input(new_report->description, size);  // fill description with random bytes from stream?
    printf("Descripton:");
    read_input(new_report->description, size);
    new_report->description_size = size;
    new_report->next = 0LL;
    new_report->prev = 0LL;
    new_report->evaluated = 0;
    AddReportToProduct(product, new_report);
  }
  else
  {
    puts(&byte_360F);
    free(new_report);                           // out of scope
  }
}

//----- (00000000000022E2) ----------------------------------------------------
int DeleteReport()
{
  int bug_id; // [rsp+Ch] [rbp-14h]
  BugReport *bugs; // [rsp+10h] [rbp-10h]
  unsigned __int64 product_id; // [rsp+18h] [rbp-8h]

  printf("Product ID:");
  product_id = read_long();
  if ( product_id > 7 )
    return puts("Invalid !");
  if ( !Products[product_id] )
    return puts("No such product !");
  printf("ID > %lu\n", product_id);
  printf("Name > %s\n", Products[product_id]->name);
  printf("Company > %s\n", Products[product_id]->company);
  if ( !Products[product_id]->bugs )
    return puts("No bug !");
  printf("Bug ID:");
  bug_id = read_long();
  bugs = Products[product_id]->bugs;
  do
  {
    if ( bug_id == LODWORD(bugs->id) )
    {
      if ( bugs->owner == user && bugs->evaluated != 1 )
      {
        --bugs->type->ref_count;
        --LODWORD(bugs->owner->report_count);
        RemoveBugFromProduct(Products[product_id], bugs);
        free(bugs->description);                // UAF?
        free(bugs);
        return puts("Done!");
      }
      puts("You are not the owner or it expired");
    }
    bugs = bugs->next;
  }
  while ( bugs != Products[product_id]->bugs );
  return puts("No such bug !");
}

//----- (0000000000002549) ----------------------------------------------------
unsigned __int64 ModifyReport()
{
  int bug_id; // [rsp+4h] [rbp-3Ch]
  BugReport *bugs; // [rsp+8h] [rbp-38h]
  unsigned __int64 product_id; // [rsp+10h] [rbp-30h]
  unsigned __int64 type_id; // [rsp+20h] [rbp-20h]
  char choice[8]; // [rsp+30h] [rbp-10h] BYREF
  unsigned __int64 v6; // [rsp+38h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  printf("Product ID:");
  product_id = read_long();
  if ( product_id <= 7 )
  {
    if ( Products[product_id] )
    {
      printf("ID > %lu\n", product_id);
      printf("Name > %s\n", Products[product_id]->name);
      printf("Company > %s\n", Products[product_id]->company);
      if ( Products[product_id]->bugs )
      {
        printf("Bug ID:");
        bug_id = read_long();
        bugs = Products[product_id]->bugs;
        while ( bug_id != LODWORD(bugs->id) )
        {
          bugs = bugs->next;
          if ( bugs == Products[product_id]->bugs )
          {
            puts("No such bug !");
            return __readfsqword(0x28u) ^ v6;
          }
        }
        printf("Title:");
        read_input(bugs->title, 255u);
        printf("Length of descripton:");
        bugs->description_size = read_long();
        if ( bugs->description_size <= 1031uLL )
          bugs->description_size = 1032LL;
        free(bugs->description);
        bugs->description = (char *)calloc(1uLL, bugs->description_size);
        if ( !bugs->description )
        {
          puts("Error!");
          _exit(-9);
        }
        printf("Descripton:");
        read_input(bugs->description, bugs->description_size);
        printf("Do you want to change to another type ? ");
        read_input(choice, 3u);
        if ( choice[0] == 'y' )                 // read 3 bytes but only check for the first one
        {
          ShowTypes();
          printf("Type:");
          type_id = read_long();
          if ( type_id <= 7 && VulnTypes[type_id] )
          {
            --bugs->type->ref_count;
            bugs->type = VulnTypes[type_id];
            ++bugs->type->ref_count;
          }
        }
        else
        {
          puts("Use old type !");
        }
      }
      else
      {
        puts("No bug !");
      }
    }
    else
    {
      puts("No such product !");
    }
  }
  return __readfsqword(0x28u) ^ v6;
}
// 2549: using guessed type char choice[8];

//----- (0000000000002907) ----------------------------------------------------
int EvalVuln()
{
  int bounty; // [rsp+0h] [rbp-10h]
  int product_id; // [rsp+4h] [rbp-Ch]
  BugReport *bugs; // [rsp+8h] [rbp-8h]

  bounty = 0;
  bugs = 0LL;
  if ( user != admin )                          // only admin
    return puts("Permission denied !");
  for ( product_id = 0; product_id <= 7; ++product_id )
  {
    if ( Products[product_id] && Products[product_id]->bugs )
    {
      bugs = Products[product_id]->bugs;
      do
      {
        if ( bugs->evaluated != 1 && bugs->type )
        {
          bounty += bugs->type->price;          // accumulate prices
          bugs->evaluated = 1;
        }
        bugs = bugs->next;
      }
      while ( bugs != Products[product_id]->bugs );
    }
  }
  if ( bugs )
    LODWORD(bugs->owner->balance) += bounty;
  return puts("Done !");
}

//----- (0000000000002A67) ----------------------------------------------------
unsigned __int64 __fastcall sub_2A67(__int64 a1, __int64 a2, __int64 a3)
{
  char v5[120]; // [rsp+20h] [rbp-80h] BYREF
  unsigned __int64 v6; // [rsp+98h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  MD5_Init(v5);
  MD5_Update(v5, a1, a3);
  MD5_Final(a2, v5);
  return __readfsqword(0x28u) ^ v6;
}
// C60: using guessed type __int64 __fastcall MD5_Final(_QWORD, _QWORD);
// C70: using guessed type __int64 __fastcall MD5_Update(_QWORD, _QWORD, _QWORD);
// CF0: using guessed type __int64 __fastcall MD5_Init(_QWORD);

//----- (0000000000002AEC) ----------------------------------------------------
unsigned __int64 UserInfo()
{
  int i; // [rsp+8h] [rbp-138h]
  int j; // [rsp+Ch] [rbp-134h]
  char s[16]; // [rsp+20h] [rbp-120h] BYREF
  char contact[128]; // [rsp+30h] [rbp-110h] BYREF
  char pass[136]; // [rsp+B0h] [rbp-90h] BYREF
  unsigned __int64 v6; // [rsp+138h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  memset(s, 0, sizeof(s));
  memset(contact, 0, sizeof(contact));
  memset(pass, 0, 128uLL);
  Hashing((__int64)user->contact, (__int64)s, 32LL);
  for ( i = 0; i <= 15; ++i )
    sprintf(&contact[2 * i], "%02X", (unsigned __int8)s[i]);
  memset(s, 0, sizeof(s));
  Hashing((__int64)user, (__int64)s, 16LL);
  for ( j = 0; j <= 15; ++j )
    sprintf(&pass[2 * j], "%02X", (unsigned __int8)s[j]);
  puts("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
  printf("Name > %s\n", user->username);
  printf("Price > %u\n", LODWORD(user->balance));
  printf("Uid > %lu\n", user->uid);
  printf("Contact-c > %s\n", contact);
  printf("Pass-c > %s\n", pass);
  puts("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
  return __readfsqword(0x28u) ^ v6;
}
// 2AEC: using guessed type char s[16];
// 2AEC: using guessed type char contact[128];
// 2AEC: using guessed type char pass[136];

//----- (0000000000002D37) ----------------------------------------------------
void RemoveUser()
{
  if ( !LODWORD(user->balance) && !LODWORD(user->report_count) && user != admin )
  {
    if ( user == user_head )
    {
      user_head = user_head->next;
      free(user);
    }
    else
    {
      while ( user_head->next && user_head->next != user )
        ;                                       // infinite loop if user is 3rd place from the head
      user_head->next = user->next;             // doesnt free 2nd user
    }
    user = 0LL;                                 // no UAF
    isLoggedIn = 0;
  }
}
// 205068: using guessed type char isLoggedIn;

//----- (0000000000002E0F) ----------------------------------------------------
void ChangePassword()
{
  int len; // eax

  if ( user && user == admin )                  // only admin can change their own password
  {
    printf("New password:");
    len = strlen(user->password);
    read_input(user->password, len + 1);
  }
  else
  {
    puts("permission denied");
  }
}

//----- (0000000000002E79) ----------------------------------------------------
void ChangeContact()
{
  int len; // eax

  if ( user && user == admin )
  {
    printf("Contact:");
    len = strlen(user->contact);
    read_input(user->contact, len + 1);
  }
  else
  {
    puts("permission denied");
  }
}

//----- (0000000000002EEB) ----------------------------------------------------
__int64 Bounty()
{
  __int64 result; // rax

  while ( 1 )
  {
    BountyMenu();
    result = read_long();
    switch ( result )
    {
      case 0LL:
        return result;
      case 1LL:
        AddProduct();                           // safe for now
        break;
      case 2LL:
        AddVulnType();                          // arbitrary size allocation
        break;
      case 3LL:
        SubmitReport();                         // duplicate bug report id; arbitrary large size allocation
        break;
      case 4LL:
        RemoveVulnType();                       // arbitrary size allocation
        break;
      case 5LL:
        ModifyReport();                         // safe for now
        break;
      case 6LL:
        ShowVulnDetail();                       // possible of infinite loop -> DOS
        break;
      case 7LL:
        EvalVuln();                             // safe for now
        break;
      case 8LL:
        DeleteReport();                         // UAF?
        break;
      default:
        puts("Invalid Choice");
        break;
    }
  }
}

//----- (0000000000002FB0) ----------------------------------------------------
_DWORD *sub_2FB0()
{
  stream = fopen("/dev/urandom", "r");
  if ( !stream )
    _exit(-1);
  setvbuf(stdin, 0LL, 2, 0LL);
  setvbuf(stdout, 0LL, 2, 0LL);
  setvbuf(stderr, 0LL, 2, 0LL);
  setvbuf(stream, 0LL, 2, 0LL);
  signal(14, (__sighandler_t)handler);
  AllocateType("RCE", 10000);
  AllocateType("XSS", 500);
  return AllocateType("DoS", 777);
}

//----- (00000000000030A3) ----------------------------------------------------
void __fastcall __noreturn main(const char *a1, char **a2, char **a3)
{
  setup();
  while ( 1 )
  {
    Menu();
    switch ( read_long() )
    {
      case 0LL:
        _exit(0);
      case 1LL:
        if ( isLoggedIn )
          Bounty();
        else
          Login();
        break;
      case 2LL:
        if ( isLoggedIn )
          ChangePassword();
        else
          Register();
        break;
      case 3LL:
        ShowProduct();
        break;
      case 4LL:
        if ( isLoggedIn )
          ChangeContact();
        break;
      case 5LL:
        if ( isLoggedIn )
          RemoveUser();                         // infinite loop -> DOS
        break;
      case 6LL:
        if ( isLoggedIn )
          UserInfo();
        break;
      case 7LL:
        if ( isLoggedIn )
        {
          isLoggedIn = 0;                       // logout
          user = 0LL;
        }
        break;
      default:
        puts("Invalid Choice");
        break;
    }
  }
}
// 205068: using guessed type char isLoggedIn;

//----- (0000000000003200) ----------------------------------------------------
void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)
{
  signed __int64 v4; // rbp
  __int64 i; // rbx

  v4 = &off_204CF0 - &funcs_3249;
  init_proc();
  if ( v4 )
  {
    for ( i = 0LL; i != v4; ++i )
      ((void (__fastcall *)(_QWORD, __int64, __int64))*(&funcs_3249 + i))(a1, a2, a3);
  }
}
// E50: using guessed type __int64 __fastcall sub_E50(_QWORD, _QWORD, _QWORD);
// 204CE8: using guessed type __int64 (__fastcall *funcs_3249)();
// 204CF0: using guessed type __int64 (__fastcall *off_204CF0)();

//----- (0000000000003274) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=94 queued=39 decompiled=39 lumina nreq=0 worse=0 better=0
// ALL OK, 39 function(s) have been successfully decompiled
