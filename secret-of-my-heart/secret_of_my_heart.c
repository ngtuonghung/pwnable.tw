/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
// void free(void *ptr);
// __int64 __fastcall _read_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int puts(const char *s);
// int printf(const char *format, ...);
// void *memset(void *s, int c, size_t n);
// ssize_t read(int fd, void *buf, size_t nbytes);
// __int64 _gmon_start__(void); weak
// void *malloc(size_t size);
// int atoi(const char *nptr);
// void __noreturn exit(int status);
// int __fastcall _cxa_finalize(void *);
__int64 (**sub_A60())(void);
__int64 sub_AA0(void); // weak
__int64 (**sub_AF0())(void);
__int64 sub_B30(); // weak
__int64 __fastcall read_input(char *buf, unsigned int size);
__int64 read_int();
char *__fastcall input_secret(Secret *secret, size_t size);
Secret *__fastcall clear_secret(Secret *secret);
void __noreturn super_secret();
int add_secret();
int show_secret();
int delete_secret();
int menu();
void __fastcall __noreturn main(__int64, char **, char **);
void __fastcall init(unsigned int a1, __int64 a2, __int64 a3);
void fini(void); // idb
void term_proc();
// int __fastcall __cxa_finalize(void *);
// __int64 ITM_deregisterTMCloneTable(void); weak
// __int64 Jv_RegisterClasses(void); weak

//-------------------------------------------------------------------------
// Data declarations

__int64 (__fastcall *off_201D58[2])() = { &sub_B30, &sub_AF0 }; // weak
__int64 (__fastcall *off_201D60)() = &sub_AF0; // weak
_UNKNOWN unk_201D68; // weak
void *off_202008 = &off_202008; // idb
char _bss_start; // weak
_UNKNOWN unk_202017; // weak
Secret *secret_addr;
// extern _UNKNOWN __gmon_start__; weak


//----- (0000000000000968) ----------------------------------------------------
void *init_proc()
{
  void *result; // rax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    return (void *)_gmon_start__();
  return result;
}
// 9F0: using guessed type __int64 _gmon_start__(void);

//----- (0000000000000A30) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (__fastcall *)(int, char **, char **))main, v4, &retaddr, init, fini, a3, &v5);
  __halt();
}
// A36: positive sp value 8 has been found
// A3D: variable 'v3' is possibly undefined

//----- (0000000000000A60) ----------------------------------------------------
__int64 (**sub_A60())(void)
{
  __int64 (**result)(void); // rax

  result = (__int64 (**)(void))(&unk_202017 - (_UNKNOWN *)&_bss_start);
  if ( (unsigned __int64)(&unk_202017 - (_UNKNOWN *)&_bss_start) > 0xE )
  {
    result = &ITM_deregisterTMCloneTable;
    if ( &ITM_deregisterTMCloneTable )
      return (__int64 (**)(void))ITM_deregisterTMCloneTable();
  }
  return result;
}
// 202010: using guessed type char _bss_start;
// 2020C0: using guessed type __int64 ITM_deregisterTMCloneTable(void);

//----- (0000000000000AA0) ----------------------------------------------------
__int64 sub_AA0()
{
  return 0LL;
}
// AA0: using guessed type __int64 sub_AA0();

//----- (0000000000000AF0) ----------------------------------------------------
__int64 (**sub_AF0())(void)
{
  __int64 (**result)(void); // rax

  if ( !_bss_start )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(off_202008);
    result = sub_A60();
    _bss_start = 1;
  }
  return result;
}
// 202010: using guessed type char _bss_start;

//----- (0000000000000B30) ----------------------------------------------------
__int64 sub_B30()
{
  if ( unk_201D68 && &Jv_RegisterClasses )
    Jv_RegisterClasses();
  return sub_AA0();
}
// AA0: using guessed type __int64 sub_AA0(void);
// B30: using guessed type __int64 sub_B30();
// 2020D0: using guessed type __int64 Jv_RegisterClasses(void);

//----- (0000000000000B60) ----------------------------------------------------
__int64 setup()
{
  unsigned int v0; // eax
  __int64 result; // rax
  signed int v2; // [rsp+Ch] [rbp-4h]

  v2 = 0;
  setvbuf(stdout, 0LL, 2, 0LL);
  setvbuf(stdin, 0LL, 2, 0LL);
  v0 = time(0LL);
  srand(v0);
  while ( v2 <= 0x10000 )
    v2 = rand() & 0xFFFFF000;
  secret_addr = mmap((void *)v2, 0x1000uLL, 3, 34, -1, 0LL);
  result = secret_addr;
  if ( secret_addr == -1LL )
  {
    puts("mmap error");
    exit(0);
  }
  return result;
}

//----- (0000000000000C38) ----------------------------------------------------
__int64 __fastcall sub_C38(char *buf, unsigned int size)
{
  int v3; // [rsp+1Ch] [rbp-4h]

  v3 = read(0, buf, size);
  if ( v3 <= 0 )
  {
    puts("read error");
    exit(1);
  }
  if ( buf[v3 - 1] == 10 )
    buf[v3 - 1] = 0;
  return (unsigned int)v3;
}

//----- (0000000000000CA9) ----------------------------------------------------
__int64 read_int()
{
  char nptr[24]; // [rsp+10h] [rbp-20h] BYREF
  unsigned __int64 v2; // [rsp+28h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  if ( (int)_read_chk(0LL, nptr, 15LL, 15LL) <= 0 )
  {
    puts("read error");
    exit(1);
  }
  return (unsigned int)atoi(nptr);
}
// 9A8: using guessed type __int64 __fastcall _read_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000000D27) ----------------------------------------------------
char *__fastcall input_secret(Secret *secret, size_t size)
{
  char *result; // rax

  secret->size = size;
  printf("Name of heart :");
  read_input(secret->name, 32u);
  secret->content = (char *)malloc(size);
  if ( !secret->content )
  {
    puts("Allocate Error !");
    exit(0);
  }
  printf("secret of my heart :");
  result = &secret->content[(int)read_input(secret->content, size)];
  *result = 0;
  return result;
}

//----- (0000000000000DE4) ----------------------------------------------------
Secret *__fastcall clear_secret(Secret *secret)
{
  Secret *result; // rax

  secret->size = 0LL;
  memset(secret->name, 0, sizeof(secret->name));
  free(secret->content);
  result = secret;
  secret->content = 0LL;
  return result;
}

//----- (0000000000000E34) ----------------------------------------------------
void __noreturn super_secret()
{
  printf("Your secret : %p\n", secret_addr);
  puts("Good bye ~");
  exit(0);
}

//----- (0000000000000E6C) ----------------------------------------------------
int add_secret()
{
  int index; // [rsp+4h] [rbp-Ch]
  size_t size; // [rsp+8h] [rbp-8h]

  for ( index = 0; ; ++index )
  {
    if ( index > 99 )
      return puts("Fulled !!");
    if ( !secret_addr[index].content )
      break;
  }
  printf("Size of heart : ");
  size = (int)read_int();
  if ( size > 256 )
    return puts("Too big !");
  input_secret(&secret_addr[index], size);
  return puts("Done !");
}

//----- (0000000000000F3C) ----------------------------------------------------
int show_secret()
{
  unsigned int index; // [rsp+Ch] [rbp-4h]

  printf("Index :");
  index = read_int();
  if ( index > 99 )
  {
    puts("Out of bound !");
    exit(-2);
  }
  if ( !secret_addr[index].content )
    return puts("No such heap !");
  printf("Index : %d\n", index);
  printf("Size : %lu\n", secret_addr[index].size);
  printf("Name : %s\n", secret_addr[index].name);
  return printf("Secret : %s\n", secret_addr[index].content);
}

//----- (000000000000106D) ----------------------------------------------------
int delete_secret()
{
  unsigned int index; // [rsp+Ch] [rbp-4h]

  printf("Index :");
  index = read_int();
  if ( index > 99 )
  {
    puts("Out of bound !");
    exit(-2);
  }
  if ( !secret_addr[index].content )
    return puts("No such heap !");
  clear_secret(&secret_addr[index]);
  return puts("Done !");
}

//----- (0000000000001117) ----------------------------------------------------
int menu()
{
  puts("==================================");
  puts("        Secret of my heart        ");
  puts("==================================");
  puts(" 1. Add a secret                  ");
  puts(" 2. show a secret                 ");
  puts(" 3. delete a secret               ");
  puts(" 4. Exit                          ");
  puts("==================================");
  return printf("Your choice :");
}

//----- (000000000000118F) ----------------------------------------------------
void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)
{
  int choice; // eax

  setup();
  while ( 1 )
  {
    while ( 1 )
    {
      menu();
      choice = read_int();
      if ( choice != 3 )
        break;
      delete_secret();
    }
    if ( choice > 3 )
    {
      if ( choice == 4 )
        exit(0);
      if ( choice == 4869 )
        super_secret();
invalid:
      puts("Invalid choice");
    }
    else if ( choice == 1 )
    {
      add_secret();
    }
    else
    {
      if ( choice != 2 )
        goto invalid;
      show_secret();
    }
  }
}

//----- (0000000000001230) ----------------------------------------------------
void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)
{
  signed __int64 v4; // rbp
  __int64 i; // rbx

  v4 = &off_201D60 - off_201D58;
  init_proc();
  if ( v4 )
  {
    for ( i = 0LL; i != v4; ++i )
      ((void (__fastcall *)(_QWORD, __int64, __int64))off_201D58[i])(a1, a2, a3);
  }
}
// 968: using guessed type __int64 init_proc(void);
// 201D58: using guessed type __int64 (__fastcall *off_201D58[2])();
// 201D60: using guessed type __int64 (__fastcall *off_201D60)();

//----- (00000000000012A4) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=57 queued=19 decompiled=19 lumina nreq=0 worse=0 better=0
// ALL OK, 19 function(s) have been successfully decompiled
